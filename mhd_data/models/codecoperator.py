from __future__ import annotations

import functools
import inspect

from django.db import models

from .codec import Codec

from typing import Any, Callable, Type


def codec_operator(constructor: Callable[..., list[tuple[Type[object], str]]]) -> Callable[..., Type[Codec]]:
    """
        Turns the argument into a codec operator.
        A Codec Operator is a function that returns
        a pair of (codecClass, name).

        CodecClass should be a parent-less class
        representing a codec, and name should be
        the name of the dynamical generated
        class.
    """
    @functools.wraps(constructor)
    def wrapper(*args, **kwargs):
        clz, name = constructor(*args, **kwargs)
        return _make_applied_codec_operator(clz, name)
    return wrapper


def _make_applied_codec_operator(clz: Type[object], name: str) -> Type[Codec]:
    if models.Model in inspect.getmro(clz):
        raise ValueError(
            'Class generated by Codec Operator should not inherit from model')

    # get the dict of the class and remove the appropriate properties
    clz_meta: dict[str, Any] = dict(clz.__dict__)

    # remove the module properties directly
    clz_meta.pop('__dict__')
    clz_meta.pop('__module__')
    clz_meta.pop('__weakref__')

    # extract the CodecMeta class
    CodecMeta = clz_meta.pop('Meta', object)

    # create a new Meta-class which inherits from the above two
    class Meta(Codec.Meta, CodecMeta):
        app_label = 'mhd_data'

    # setup the property dictionary
    attrs: dict[str, Any] = {'__module__': 'mhd_data.models.codecs', 'Meta': Meta}
    attrs.update(clz_meta)

    # create the new class
    return type(name, (Codec,), attrs)
